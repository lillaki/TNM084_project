<!doctype html>
<html lang="en">
  <head>
    <title>Iris</title>
    <meta charset="utf-8">
    <style>*{box-sizing:border-box; margin:0; padding:0;}</style>
  </head>

  <body>
    <div id="container"></div>
  </body>


  <!-- <script src="/build/three.min.js"></script>
  <script type="module" src="/jsm/controls/OrbitControls.js"></script> -->

  <!-- VERTEX SHADER -->

  <script type="x-shader/x-vertex" id="vertexShader">
    varying vec2 vUv;
    varying float s;
    varying float t;

    varying vec3 Normal;
    varying vec3 Position;

    void main() {
      vUv = uv;
      s = uv.x;
      t = uv.y;

      Normal = normalize(normalMatrix * normal);
      Position = vec3(modelViewMatrix * vec4(position, 1.0));
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }

  </script>

  <!-- FRAGMENT SHADER -->
  <script type="x-shader/x-vertex" id="fragmentShader">



// Cellular noise ("Worley noise") in 2D in GLSL.
// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
// This code is released under the conditions of the MIT license.
// See LICENSE file for details.
// https://github.com/stegu/webgl-noise

// Modulo 289 without a division (only multiplications)
vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

// Modulo 7 without a division
vec3 mod7(vec3 x) {
  return x - floor(x * (1.0 / 7.0)) * 7.0;
}

// Permutation polynomial: (34x^2 + x) mod 289
vec3 permute(vec3 x) {
  return mod289((34.0 * x + 1.0) * x);
}

// Cellular noise, returning F1 and F2 in a vec2.
// Standard 3x3 search window for good F1 and F2 values
vec2 cellular(vec2 P) {
#define K 0.142857142857 // 1/7
#define Ko 0.428571428571 // 3/7
#define jitter 0.8 // Less gives more regular pattern
	vec2 Pi = mod289(floor(P));
 	vec2 Pf = fract(P);
	vec3 oi = vec3(-1.0, 0.0, 1.0);
	vec3 of = vec3(-0.5, 0.5, 1.5);
	vec3 px = permute(Pi.x + oi);
	vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13
	vec3 ox = fract(p*K) - Ko;
	vec3 oy = mod7(floor(p*K))*K - Ko;
	vec3 dx = Pf.x + 0.5 + jitter*ox;
	vec3 dy = Pf.y - of + jitter*oy;
	vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared
	p = permute(px.y + Pi.y + oi); // p21, p22, p23
	ox = fract(p*K) - Ko;
	oy = mod7(floor(p*K))*K - Ko;
	dx = Pf.x - 0.5 + jitter*ox;
	dy = Pf.y - of + jitter*oy;
	vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared
	p = permute(px.z + Pi.y + oi); // p31, p32, p33
	ox = fract(p*K) - Ko;
	oy = mod7(floor(p*K))*K - Ko;
	dx = Pf.x - 1.5 + jitter*ox;
	dy = Pf.y - of + jitter*oy;
	vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared
	// Sort out the two smallest distances (F1, F2)
	vec3 d1a = min(d1, d2);
	d2 = max(d1, d2); // Swap to keep candidates for F2
	d2 = min(d2, d3); // neither F1 nor F2 are now in d3
	d1 = min(d1a, d2); // F1 is now in d1
	d2 = max(d1a, d2); // Swap to keep candidates for F2
	d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller
	d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x
	d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz
	d1.y = min(d1.y, d1.z); // nor in  d1.z
	d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.
	return sqrt(d1.xy);
} // END OF CELLULAR NOISE

    //
    // vec3  psrdnoise(vec2 pos, vec2 per, float rot)
    // vec3  psdnoise(vec2 pos, vec2 per)
    // float psrnoise(vec2 pos, vec2 per, float rot)
    // float psnoise(vec2 pos, vec2 per)
    // vec3  srdnoise(vec2 pos, float rot)
    // vec3  sdnoise(vec2 pos)
    // float srnoise(vec2 pos, float rot)
    // float snoise(vec2 pos)
    //
    // Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise)
    // with rotating gradients and analytic derivatives.
    // Variants also without the derivative (no "d" in the name), without
    // the tiling property (no "p" in the name) and without the rotating
    // gradients (no "r" in the name).
    //
    // This is (yet) another variation on simplex noise. It's similar to the
    // version presented by Ken Perlin, but the grid is axis-aligned and
    // slightly stretched in the y direction to permit rectangular tiling.
    //
    // The noise can be made to tile seamlessly to any integer period in x and
    // any even integer period in y. Odd periods may be specified for y, but
    // then the actual tiling period will be twice that number.
    //
    // The rotating gradients give the appearance of a swirling motion, and can
    // serve a similar purpose for animation as motion along z in 3-D noise.
    // The rotating gradients in conjunction with the analytic derivatives
    // can make "flow noise" effects as presented by Perlin and Neyret.
    //
    // vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot})
    // "pos" is the input (x,y) coordinate
    // "per" is the x and y period, where per.x is a positive integer
    //    and per.y is a positive even integer
    // "rot" is the angle to rotate the gradients (any float value,
    //    where 0.0 is no rotation and 1.0 is one full turn)
    // The first component of the 3-element return vector is the noise value.
    // The second and third components are the x and y partial derivatives.
    //
    // float {p}s{r}noise(vec2 pos {, vec2 per} {, float rot})
    // "pos" is the input (x,y) coordinate
    // "per" is the x and y period, where per.x is a positive integer
    //    and per.y is a positive even integer
    // "rot" is the angle to rotate the gradients (any float value,
    //    where 0.0 is no rotation and 1.0 is one full turn)
    // The return value is the noise value.
    // Partial derivatives are not computed, making these functions faster.
    //
    // Author: Stefan Gustavson (stefan.gustavson@gmail.com)
    // Version 2016-05-10.
    //
    // Many thanks to Ian McEwan of Ashima Arts for the
    // idea of using a permutation polynomial.
    //
    // Copyright (c) 2016 Stefan Gustavson. All rights reserved.
    // Distributed under the MIT license. See LICENSE file.
    // https://github.com/stegu/webgl-noise
    //

    //
    // TODO: One-pixel wide artefacts used to occur due to precision issues with
    // the gradient indexing. This is specific to this variant of noise, because
    // one axis of the simplex grid is perfectly aligned with the input x axis.
    // The errors were rare, and they are now very unlikely to ever be visible
    // after a quick fix was introduced: a small offset is added to the y coordinate.
    // A proper fix would involve using round() instead of floor() in selected
    // places, but the quick fix works fine.
    // (If you run into problems with this, please let me know.)
    //


    float mod289(float x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    float permute(float x) {
      return mod289(((x*34.0)+1.0)*x);
    }

    // Hashed 2-D gradients with an extra rotation.
    // (The constant 0.0243902439 is 1/41)
    vec2 rgrad2(vec2 p, float rot) {
    #if 0
    // Map from a line to a diamond such that a shift maps to a rotation.
      float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift
      u = 4.0 * fract(u) - 2.0;
      // (This vector could be normalized, exactly or approximately.)
      return vec2(abs(u)-1.0, abs(abs(u+1.0)-2.0)-1.0);
    #else
    // For more isotropic gradients, sin/cos can be used instead.
      float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift
      u = fract(u) * 6.28318530718; // 2*pi
      return vec2(cos(u), sin(u));
    #endif
    }

    //
    // 2-D tiling simplex noise with rotating gradients and analytical derivative.
    // The first component of the 3-element return vector is the noise value,
    // and the second and third components are the x and y partial derivatives.
    //
    vec3 psrdnoise(vec2 pos, vec2 per, float rot) {
      // Hack: offset y slightly to hide some rare artifacts
      pos.y += 0.01;
      // Skew to hexagonal grid
      vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);
      
      vec2 i0 = floor(uv);
      vec2 f0 = fract(uv);
      // Traversal order
      vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);

      // Unskewed grid points in (x,y) space
      vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);
      vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);
      vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);

      // Integer grid point indices in (u,v) space
      i1 = i0 + i1;
      vec2 i2 = i0 + vec2(1.0, 1.0);

      // Vectors in unskewed (x,y) coordinates from
      // each of the simplex corners to the evaluation point
      vec2 d0 = pos - p0;
      vec2 d1 = pos - p1;
      vec2 d2 = pos - p2;

      // Wrap i0, i1 and i2 to the desired period before gradient hashing:
      // wrap points in (x,y), map to (u,v)
      vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);
      vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);
      vec3 iuw = xw + 0.5 * yw;
      vec3 ivw = yw;
      
      // Create gradients from indices
      vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);
      vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);
      vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);

      // Gradients dot vectors to corresponding corners
      // (The derivatives of this are simply the gradients)
      vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));
      
      // Radial weights from corners
      // 0.8 is the square of 2/sqrt(5), the distance from
      // a grid point to the nearest simplex boundary
      vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));

      // Partial derivatives for analytical gradient computation
      vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);
      vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);

      // Set influence of each surflet to zero outside radius sqrt(0.8)
      if (t.x < 0.0) {
        dtdx.x = 0.0;
        dtdy.x = 0.0;
      t.x = 0.0;
      }
      if (t.y < 0.0) {
        dtdx.y = 0.0;
        dtdy.y = 0.0;
      t.y = 0.0;
      }
      if (t.z < 0.0) {
        dtdx.z = 0.0;
        dtdy.z = 0.0;
      t.z = 0.0;
      }

      // Fourth power of t (and third power for derivative)
      vec3 t2 = t * t;
      vec3 t4 = t2 * t2;
      vec3 t3 = t2 * t;
      
      // Final noise value is:
      // sum of ((radial weights) times (gradient dot vector from corner))
      float n = dot(t4, w);
      
      // Final analytical derivative (gradient of a sum of scalar products)
      vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;
      vec2 dn0 = t4.x * g0 + dt0 * w.x;
      vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;
      vec2 dn1 = t4.y * g1 + dt1 * w.y;
      vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;
      vec2 dn2 = t4.z * g2 + dt2 * w.z;

      return 11.0*vec3(n, dn0 + dn1 + dn2);
    }

    //
    // 2-D tiling simplex noise with fixed gradients
    // and analytical derivative.
    // This function is implemented as a wrapper to "psrdnoise",
    // at the minimal cost of three extra additions.
    //
    vec3 psdnoise(vec2 pos, vec2 per) {
      return psrdnoise(pos, per, 0.0);
    }

    //
    // 2-D tiling simplex noise with rotating gradients,
    // but without the analytical derivative.
    //
    float psrnoise(vec2 pos, vec2 per, float rot) {
      // Offset y slightly to hide some rare artifacts
      pos.y += 0.001;
      // Skew to hexagonal grid
      vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);
      
      vec2 i0 = floor(uv);
      vec2 f0 = fract(uv);
      // Traversal order
      vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);

      // Unskewed grid points in (x,y) space
      vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);
      vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);
      vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);

      // Integer grid point indices in (u,v) space
      i1 = i0 + i1;
      vec2 i2 = i0 + vec2(1.0, 1.0);

      // Vectors in unskewed (x,y) coordinates from
      // each of the simplex corners to the evaluation point
      vec2 d0 = pos - p0;
      vec2 d1 = pos - p1;
      vec2 d2 = pos - p2;

      // Wrap i0, i1 and i2 to the desired period before gradient hashing:
      // wrap points in (x,y), map to (u,v)
      vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);
      vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);
      vec3 iuw = xw + 0.5 * yw;
      vec3 ivw = yw;
      
      // Create gradients from indices
      vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);
      vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);
      vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);

      // Gradients dot vectors to corresponding corners
      // (The derivatives of this are simply the gradients)
      vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));
      
      // Radial weights from corners
      // 0.8 is the square of 2/sqrt(5), the distance from
      // a grid point to the nearest simplex boundary
      vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));

      // Set influence of each surflet to zero outside radius sqrt(0.8)
      t = max(t, 0.0);

      // Fourth power of t
      vec3 t2 = t * t;
      vec3 t4 = t2 * t2;
      
      // Final noise value is:
      // sum of ((radial weights) times (gradient dot vector from corner))
      float n = dot(t4, w);
      
      // Rescale to cover the range [-1,1] reasonably well
      return 11.0*n;
    }

    //
    // 2-D tiling simplex noise with fixed gradients,
    // without the analytical derivative.
    // This function is implemented as a wrapper to "psrnoise",
    // at the minimal cost of three extra additions.
    //
    float psnoise(vec2 pos, vec2 per) {
      return psrnoise(pos, per, 0.0);
    }

    //
    // 2-D non-tiling simplex noise with rotating gradients and analytical derivative.
    // The first component of the 3-element return vector is the noise value,
    // and the second and third components are the x and y partial derivatives.
    //
    vec3 srdnoise(vec2 pos, float rot) {
      // Offset y slightly to hide some rare artifacts
      pos.y += 0.001;
      // Skew to hexagonal grid
      vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);
      
      vec2 i0 = floor(uv);
      vec2 f0 = fract(uv);
      // Traversal order
      vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);

      // Unskewed grid points in (x,y) space
      vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);
      vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);
      vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);

      // Integer grid point indices in (u,v) space
      i1 = i0 + i1;
      vec2 i2 = i0 + vec2(1.0, 1.0);

      // Vectors in unskewed (x,y) coordinates from
      // each of the simplex corners to the evaluation point
      vec2 d0 = pos - p0;
      vec2 d1 = pos - p1;
      vec2 d2 = pos - p2;

      vec3 x = vec3(p0.x, p1.x, p2.x);
      vec3 y = vec3(p0.y, p1.y, p2.y);
      vec3 iuw = x + 0.5 * y;
      vec3 ivw = y;
      
      // Avoid precision issues in permutation
      iuw = mod289(iuw);
      ivw = mod289(ivw);

      // Create gradients from indices
      vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);
      vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);
      vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);

      // Gradients dot vectors to corresponding corners
      // (The derivatives of this are simply the gradients)
      vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));
      
      // Radial weights from corners
      // 0.8 is the square of 2/sqrt(5), the distance from
      // a grid point to the nearest simplex boundary
      vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));

      // Partial derivatives for analytical gradient computation
      vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);
      vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);

      // Set influence of each surflet to zero outside radius sqrt(0.8)
      if (t.x < 0.0) {
        dtdx.x = 0.0;
        dtdy.x = 0.0;
      t.x = 0.0;
      }
      if (t.y < 0.0) {
        dtdx.y = 0.0;
        dtdy.y = 0.0;
      t.y = 0.0;
      }
      if (t.z < 0.0) {
        dtdx.z = 0.0;
        dtdy.z = 0.0;
      t.z = 0.0;
      }

      // Fourth power of t (and third power for derivative)
      vec3 t2 = t * t;
      vec3 t4 = t2 * t2;
      vec3 t3 = t2 * t;
      
      // Final noise value is:
      // sum of ((radial weights) times (gradient dot vector from corner))
      float n = dot(t4, w);
      
      // Final analytical derivative (gradient of a sum of scalar products)
      vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;
      vec2 dn0 = t4.x * g0 + dt0 * w.x;
      vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;
      vec2 dn1 = t4.y * g1 + dt1 * w.y;
      vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;
      vec2 dn2 = t4.z * g2 + dt2 * w.z;

      return 11.0*vec3(n, dn0 + dn1 + dn2);
    }

    //
    // 2-D non-tiling simplex noise with fixed gradients and analytical derivative.
    // This function is implemented as a wrapper to "srdnoise",
    // at the minimal cost of three extra additions.
    //
    vec3 sdnoise(vec2 pos) {
      return srdnoise(pos, 0.0);
    }

    //
    // 2-D non-tiling simplex noise with rotating gradients,
    // without the analytical derivative.
    //
    float srnoise(vec2 pos, float rot) {
      // Offset y slightly to hide some rare artifacts
      pos.y += 0.001;
      // Skew to hexagonal grid
      vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);
      
      vec2 i0 = floor(uv);
      vec2 f0 = fract(uv);
      // Traversal order
      vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);

      // Unskewed grid points in (x,y) space
      vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);
      vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);
      vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);

      // Integer grid point indices in (u,v) space
      i1 = i0 + i1;
      vec2 i2 = i0 + vec2(1.0, 1.0);

      // Vectors in unskewed (x,y) coordinates from
      // each of the simplex corners to the evaluation point
      vec2 d0 = pos - p0;
      vec2 d1 = pos - p1;
      vec2 d2 = pos - p2;

      // Wrap i0, i1 and i2 to the desired period before gradient hashing:
      // wrap points in (x,y), map to (u,v)
      vec3 x = vec3(p0.x, p1.x, p2.x);
      vec3 y = vec3(p0.y, p1.y, p2.y);
      vec3 iuw = x + 0.5 * y;
      vec3 ivw = y;
      
      // Avoid precision issues in permutation
      iuw = mod289(iuw);
      ivw = mod289(ivw);

      // Create gradients from indices
      vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);
      vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);
      vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);

      // Gradients dot vectors to corresponding corners
      // (The derivatives of this are simply the gradients)
      vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));
      
      // Radial weights from corners
      // 0.8 is the square of 2/sqrt(5), the distance from
      // a grid point to the nearest simplex boundary
      vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));

      // Set influence of each surflet to zero outside radius sqrt(0.8)
      t = max(t, 0.0);

      // Fourth power of t
      vec3 t2 = t * t;
      vec3 t4 = t2 * t2;
      
      // Final noise value is:
      // sum of ((radial weights) times (gradient dot vector from corner))
      float n = dot(t4, w);
      
      // Rescale to cover the range [-1,1] reasonably well
      return 11.0*n;
    }

    //
    // 2-D non-tiling simplex noise with fixed gradients,
    // without the analytical derivative.
    // This function is implemented as a wrapper to "srnoise",
    // at the minimal cost of three extra additions.
    // Note: if this kind of noise is all you want, there are faster
    // GLSL implementations of non-tiling simplex noise out there.
    // This one is included mainly for completeness and compatibility
    // with the other functions in the file.
    //
    float snoise(vec2 pos) {
      return srnoise(pos, 0.0);
    }

    varying vec2 vUv;
    varying float s;
    varying float t;

    uniform float pupilSize;
    uniform float irisSize;
    uniform float irisOuterBound;
    uniform float whiteBlur;

    varying vec3 Normal;
    varying vec3 Position;

    uniform vec3 Ka;
    uniform vec3 Kd;
    uniform vec3 Ks;
    uniform vec4 LightPosition;
    uniform vec3 LightIntensity;
    uniform float Shininess;

    // PHONG MODEL

    vec3 phong() {
      vec3 n = normalize(Normal);
      vec3 s = normalize(vec3(LightPosition) - Position);
      vec3 v = normalize(vec3(-Position));
      vec3 r = reflect(-s, n);

      vec3 ambient = Ka;
      vec3 diffuse = Kd * max(dot(s, n), 0.0);
      vec3 specular = Ks * pow(max(dot(r, v), 0.0), Shininess);

      return LightIntensity * (ambient + diffuse + specular);
    }

    void main() {

      float pupilNoise = 0.0;
      float irisNoiseStripes = 0.0;
      vec2 irisNoiseHoles = vec2(0.0);

      // Noise
      pupilNoise = psnoise(vec2(s*5.0,t*0.5)*10.0, vec2(10.0))*0.2;
      irisNoiseStripes = psnoise(vec2(s*0.3,s)*10.0, vec2(1.))*0.3 + 0.5;
      irisNoiseHoles = cellular(vec2(s*10.0,t*10.0))*4.0;

      vec3 whiteColor = vec3(1.0, 1.0, 1.0).rgb;
      vec3 blackColor = vec3(0.0, 0.0, 0.0).rgb;
      vec3 pupillaryBoundColor = vec3(0.0, 0.0, 0.0).rgb;
      vec3 irisColor = vec3(0.74, 0.89, 1.0).rgb; // Lightblue
      vec3 irisColor2 = vec3(0.0, 1.0, 0.0).rgb; // Green

      vec3 irisBoundryColor = vec3(1.0, 0.0, 0.0).rgb;

      //vec3 finalIris = mix(irisColor2, irisColor*irisNoiseStripes, vec3(step(irisNoiseHoles, vec2(0.2, 0.0)), 1.0) );
      vec3 finalIris = mix(irisColor2, irisColor*irisNoiseStripes, step(0.5, irisNoiseHoles.x));

      vec3 irisBoundry = mix(irisBoundryColor, whiteColor, smoothstep(irisOuterBound, whiteBlur, t));
      vec3 irisPupillaryZone = mix(finalIris, irisBoundry, smoothstep(irisSize, irisSize - 0.07, t));
      vec3 pupillaryBound  = mix(pupillaryBoundColor, irisPupillaryZone, smoothstep(pupilSize, pupilSize - 0.015, t));

      gl_FragColor = vec4(phong()*pupillaryBound, 1.0);
    }
  </script>


  <!-- MAIN CODE -->
  <script type="module" id="mainCode">

    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.112.0/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.112.0/examples/jsm/controls/OrbitControls.js";
    import {color, controllers, dom, gui, GUI} from "./dat.gui.module.js";
 
     // VARIABLES
    var container, canvas, context, renderer, scene, camera, controls, geometry,
    mesh, start = Date.now(), fov = 30;

    var wireframe, line, material, linematerial, lights, uniforms;

    // Get shaders by textContent
    var vertexShader = document.getElementById( 'vertexShader' ).textContent;
    var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;

    container = document.getElementById( "container" );

    // WEBGL 
    canvas = document.createElement( 'canvas' );
    context = canvas.getContext( 'webgl2', { alpha: false } );

    // RENDERER 
    renderer = new THREE.WebGLRenderer( { canvas: canvas, context: context } );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setPixelRatio( window.devicePixelRatio );
    container.appendChild( renderer.domElement );

    // SCENE AND CAMERA 
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.z = 100;

    // CONTROLS
    controls = new OrbitControls( camera, renderer.domElement );

    // SPHERE
    geometry = new THREE.IcosahedronGeometry( 15, 5 );
    geometry.rotateX( Math.PI / 2 );

    // LIGHTS
    var light = new THREE.PointLight( 0xa5ccff, 1 );
    light.position.set(300,300,0);
    scene.add( light );

    var phongShader = THREE.ShaderLib.phong;

    // UNIFORMS FOR THE SHADERS
    var uniforms = THREE.UniformsUtils.merge([
          { pupilSize: { value: 0.93 },
            irisSize: { value: 0.86 },
            whiteBlur: { value: 0.75 },
            irisOuterBound: { value: 0.80 },
            Ka: { value: new THREE.Vector3(1.0, 1.0, 1.0) },
            Kd: { value: new THREE.Vector3(0.9, 0.7, 0.5) },
            Ks: { value: new THREE.Vector3(0.8, 0.8, 0.8) },
            LightIntensity: { value: new THREE.Vector4(0.6, 0.6, 0.6, 1.0) },
            LightPosition: { value: new THREE.Vector4(60.0, 30.0, 30.0, 1.0) },
            Shininess: { value: 100.0 }
            }
      ]);
      
    // Add the light uniforms
    var mUniforms = THREE.UniformsUtils.merge([phongShader.uniforms, uniforms]);

    // MATERIAL
    material = new THREE.ShaderMaterial( {
      uniforms: mUniforms, 
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      lights: true,
    } );

    // Mesh for debugging purposes
    mesh = new THREE.Mesh(geometry, material);
    scene.add( mesh );

    // DAT.GUI 
    // Creating a GUI with options.
    var myGui = new gui.GUI({name: 'My GUI'});
    var bFolder = myGui.addFolder('Bounderies');
    var cFolder = myGui.addFolder('Colors');
    
    // Add a string controller.
    bFolder.add(material.uniforms.pupilSize, 'value', 0, 1, 0.01).name('pupilSize');
    bFolder.add(material.uniforms.irisSize, 'value', 0, 1, 0.01).name('irisSize');
    bFolder.add(material.uniforms.whiteBlur, 'value', 0, 1, 0.01).name('whiteBlur');
    bFolder.add(material.uniforms.irisOuterBound, 'value', 0, 1, 0.01).name('irisOuterBound');
    bFolder.add(material.uniforms.irisOuterBound, 'value', 0, 1, 0.01).name('irisOuterBound');

    // RENDER WITH THE SHADERS
    render();

    // MESH WIREFRAME
    wireframe = new THREE.WireframeGeometry( geometry );
    linematerial = new THREE.LineBasicMaterial({
      color: 0xffffff
    }); 

    line = new THREE.LineSegments( wireframe, linematerial );
    line.material.depthTest = true;
    line.transparent = false;
    line.material.opacity = 0.25; 
    // scene.add( line );

  // EVENT LISTENER
  onWindowResize();
  window.addEventListener( 'resize', onWindowResize, false );

  function onWindowResize () {
    renderer.setSize( window.innerWidth, window.innerHeight );
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  }

  function render() {
    renderer.render( scene, camera );
    requestAnimationFrame( render );
  }
  </script>

</html>
